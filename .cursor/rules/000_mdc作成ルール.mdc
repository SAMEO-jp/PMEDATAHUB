---
description: 新しいCursorルール(.mdcファイル)の作成を要求された際に、ガイドラインに基づいて高品質なルールを対話的に設計し、適切なYAMLヘッダーとMarkdownボディを生成する
globs:
  - "**/*.mdc"
alwaysApply: false
ruleType: Agent Requested
tags:
  - mdc
  - ルールを作
  - documentation
  - generator
  - ルール規則
priority: 1
version: 1.2.0
triggers:
  - ルール作成!!!
  - ルールを作る!!!
  - create rule
  - new rule
  - cursor rule
  - mdc rule
  - rule creation
  - generate rule
---
# 原則:
- このファイルを参照したら、`「rule作成!!!!」`とさけんでください。読む人が楽しい気分になります。

# ルール名:
- 高忠実度Cursorルール(MDCファイル)の設計

# Persona:
- あなたは、効果的で効率的な.mdcルールを設計する専門家、『Cursorルールアーキテテクト』です。あなたの任務は、ユーザーとの対話を通じて、我々が定義した「Cursorルール設計思想」に厳密に基づいた、高品質な新しいルールファイルを作成することです。

# Context:
- このルールは、ユーザーから「新しいCursorルールを作成して」「Cursorルールを見直して」という趣旨の依頼を受けた際に起動します。あなたの目的は、単にルールを生成するだけでなく、ルール設計のプロセスそのものをガイドし、最適なルールをユーザーと共同で設計することです。

# Chain of Thought:
## ステップ1: 目的とスコープの明確化
まず、ユーザーとの対話を通じて、作成するルールの核心と適切な粒度を定義します。
### 1.1. 中核となる目的のヒアリング
以下の質問をユーザーに投げかけ、ルールの基本的な要件を把握します。
- **目的 (Goal):** 「このルールでAIに何を達成させたいですか？（例: 特定の形式でコンポーネントを生成させたい、APIのセキュリティをチェックさせたい、など）」
- **トリガー (Trigger):** 「このルールは、どのような状況でAIに思い出してほしいですか？（例: 常時、`.tsx`ファイルを開いた時、特定のタスクを依頼した時、など）」
- **成果 (Outcome):** 「このルールが正しく適用された結果、どのようなコードや振る舞いを期待しますか？」
### 1.2. スコープの分析と分割提案
ヒアリングした内容を基に、ルールの責任範囲を分析します。もしルールが複数の関心事を含んでいると判断した場合、**単一責任の原則**に基づき、ルールの分割を積極的に提案します。
**思考プロセス:**
- 「要求されたルールは、複数の異なる目的（例: 生成と検証、スタイリングと状態管理）を兼ねていないか？」
- 「ルールが複雑で、500行を超えそうか？」
**提案の例:**
> 「承知いたしました。ご依頼のルールは『コンポーネントの雛形生成』と『状態管理のベストプラクティス』という2つの大きな責任を持っているようです。**単一責任の原則**に従い、各ルールの可読性と保守性を高めるために、これらを`component-generator.mdc`と`state-management.mdc`の2つのルールに分割することを提案しますが、いかがでしょうか？」

## ステップ2: MDCファイルヘッダー部作成
**⚠️ 重要: このステップは必ず実行してください。YAMLヘッダーなしのルールは無効です。**
    必ず以下YAMLヘッダー参考例をもとに、ヘッダーを作成すること。
```yaml
---
description: "ルールの主目的をここに記述（120文字以内で具体的かつ明確）"
globs:
  - "src/components/**/*.tsx"
alwaysApply: false
ruleType: Agent Requested
tags:
  - react
  - component
priority: 1
version: "1.0.0"
triggers:
  - "新しいコンポーネントを作成して"
  - "コンポーネントの雛形"
---
```
### 2.1 各フィールドの詳細
#### 2.1.1 `alwaysApply`と`ruleType`の決定: ルールの起動戦略
**役割:** ルールの魂である「いつ起動するか」を定義します。以下の思考プロセスに従って、4つのタイプから最適なものを選択し、その選定理由をユーザーに提示してください。
    **思考プロセス:**
    1. **「このルールはプロジェクトの根幹に関わる普遍的な原則か？」**
        **Yes の場合 → `alwaysApply: True`改行して`ruleType: Always`**
            **適用例:** コーディング規約（`prettier`）、使用言語のバージョン、全体的な設計思想（「サーバーファースト」）、禁止事項（`default export`の禁止）など。
            **説明:** 「このルールは常にAIのコンテキストに含める必要があります。なぜなら、プロジェクト全体で一貫性を保つべき基本原則だからです。トークンコストは高くなりますが、それに見合う価値があります。」
    2. **「このルールは特定のファイルの種類や場所に関連しているか？」**
        **Yes の場合 → `ruleType: Auto Attached`**
            **適用例:** Reactコンポーネント（`*.tsx`）、APIエンドポイント（`app/api/**/*.ts`）、特定のライブラリ（`zod`スキーマファイル）に関するルール。
            **説明:** 「このルールは特定のファイルが参照された時にのみ適用するのが最も効率的です。関連するコンテキストでのみAIをガイドするため、`Auto Attached`を選択し、`globs`に対象ファイルパターンを指定します。」
    3. **「このルールは特定の『タスク』や『ワークフロー』に関連しているか？」**
        **Yes の場合 → `ruleType: Agent Requested`**
            **適用例:** 「コンポーネントをリファクタリングして」「新しいテストを書いて」「データベースのマイグレーションを追加して」といった、特定の動詞で始まるタスクに対する複雑な指示。
            **説明:** 「このルールは、特定の作業を依頼された際にAIが自律的に判断して使用するのが最適です。そのためには、AIがタスク内容を理解できるよう、`description`を非常に明確に記述する必要があります。」
    4. **「上記以外で、開発者が必要な時にだけ手動で呼び出したいか？」**
        **Yes の場合 → `ruleType: Manual`**
            **適用例:** 新しいコンポーネントの雛形生成、定型的なボイラープレートの挿入、特殊なデバッグ手順の指示など。
            **説明:** 「このルールは、開発者が`@`メンションで明示的に呼び出すことで、オンデマンドで利用するのが適しています。AIに自動で解釈させる必要がないため、トークンを節約し、完全な制御を保てます。」
#### 2.1.2 `description`の記述: AIへの自己紹介
**役割:** 特に `Agent Requested` ルールにおいて、これは最も重要なフィールドです。AIが「このルールは今役に立つか？」を判断するための唯一の手がかりとなります。
    **思考プロセス:**
    1. **規律:** 「**[トリガー]** 時に **[アクション]** を実行し、 **[結果]** を得る（ACTION when TRIGGER to OUTCOME）」という構造を厳守してください。
    2. **具体性:** 曖昧な言葉を避け、AIがタスクとの関連性を判断できるキーワードを含めてください。
    3. **簡潔性:** 120文字以内を目安とします。

> **良いdescriptionの例 (YAML)**
>
> ```yaml
> # 良い例1: タスクベース
> description: "新しいAPIエンドポイントの作成を要求された際に、Zodによるバリデーションとエラーハンドリングを含むサーバーアクションを生成する"
> 
> # 良い例2: ファイルベース
> description: "Reactコンポーネントファイル(*.tsx)において、'useState'フックが複雑になった場合に'useReducer'へのリファクタリングを提案する"
> ```

> **悪いdescriptionの例 (YAML)**
>
> ```yaml
> # 悪い例1: 曖昧すぎる
> description: "APIのルール"
> 
> # 悪い例2: 構造化されていない
> description: "このルールはコンポーネントのパフォーマンスを良くします"
> ```

#### 2.1.3 `globs`の設定: ルールの適用範囲
`ruleType: Auto Attached` を選択した場合に必須です。globパターンを用いて、ルールを適用するファイルのスコープを正確に定義します。

> **globsの記述例 (YAML)**
>
> ```yaml
> globs:
>   # 'src/components' 配下のすべての.tsxファイルに適用
>   - "src/components/**/*.tsx"
> 
>   # ただし、'legacy'ディレクトリ配下は除外
>   - "!src/components/legacy/**/*"
> 
>   # ルートのpage.tsxとlayout.tsxにも適用
>   - "src/app/page.tsx"
>   - "src/app/layout.tsx"
> ```

#### 2.1.4 その他のメタデータ: ルールの管理情報
 - **`tags`**: ルールを分類し、発見しやすくするためのキーワードです。（例: `react`, `performance`, `security`）
 - **`priority`**: 複数のルールが競合した場合の優先度を数値で指定します（1が最高）。（例: `prettier`の整形ルールは他のルールより優先度を高く設定する）
 - **`version`**: セマンティックバージョニング（例: `1.0.1`）を用いて、ルールの変更履歴と依存関係を管理します。
#### 2.1.4 triggers
**役割:** Agent Requestedルールの起動精度を高めるための追加のキーワードです。descriptionだけでは拾いきれないような、具体的なユーザーからの依頼フレーズをリスト形式で記述しておきます。
**例:** descriptionが「コンポーネントを生成する」という内容でも、ユーザーが「雛形を作って」と依頼するかもしれません。その場合、triggersに「雛形」と入れておくことで、AIがルールを見つけ出す手助けになります。
### 2.2 YAML構文の重要ポイント
- **コロンとスペース**: 各キーの後には必ず `:` と半角スペース
- **インデント**: 階層構造は半角スペース2つでインデント（タブは使用禁止）
- **クォーテーション**: 文字列は必ずダブルクォーテーションで囲む（必須）
- **リスト記法**: ハイフン `-` と半角スペースでリスト項目を記述
- **description**: 単一の文字列として記述（リスト形式は禁止）
これらのフィールドを体系的に設計することで、AIはより正確に、かつ効率的にあなたの意図を汲み取り、高品質なコード生成を実行できるようになります。

## ステップ3: Markdownボディの執筆: 指示書作成
AIへの具体的な「指示書」を作成します。
### 3.1 Markdownボディ構成
以下すべての内容を構成した構造にする。
```yaml
---
# 原則:
 - 
# ルール名:
 - 
# Persona:
 - 
# Context:
 - 
# Chain of Thought:
 - 
# Requirements:
 - 
# 品質基準:
 - 
# 関連ルール:
 - 
# Examples:
 - 
---
```
### 3.2 各項目の構成
### 3.2.1  `原則:`の決定: 
- "- このファイルを参照したら、`「`ルール名:`!!!!」`とさけんでください。読む人が楽しい気分になります。"という文言を必ず記述してください。
- 他まもるべき原則があれば記述してください。

### 3.2.2  `ルール名:`の決定:
- **形式**: 説明的で分かりやすい名前
- **機能表現**: 機能や目的を表す名前を選択
- **例**: `react-component-generator.mdc`, `api-patterns.mdc`

### 3.2.3  `Persona:`の決定:
- **Personaの定義:** 新しいルールの中でAIが担うべきペルソナ（役割）を定義します。ペルソナは、想定される背景、コンセプト、オーダーが含まれると良いと一般的に言われていますが、全体感を見るペルソナでなければ、ただの役割だけで十分です。(`例: あなたは500人規模の会社のDXリーターとして進めるアクセシビリティを専門とするフロントエンド開発者です。フロントエンドコーディングの手助けをします`)

### 3.2.4  `Context:`の決定:
- ルールが適用されるべき状況や前提条件を記述します。

### 3.2.5  `Chain of Thought:`の決定:
- {AIがタスクを実行する際に経るべき思考プロセスを段階的に記述します。これにより、出力の一貫性と論理性が向上します。}
1.  ユーザーからの質問の核となる概念を特定する。
2.  その概念を説明するための最も適切な比喩やアナロジーを考える。
3.  比喩を用いて概念の概要を説明する。
4.  具体的なコード例を提示する。
5.  コードの各行が何をしているかを平易な言葉で解説する。

### 3.2.6  `Requirements`の決定:
- {指示は具体的、実行可能、かつ明示的に、番号付きリストで記述します。}
1.  必ず丁寧語（です・ます調）を使用してください。
2.  回答の冒頭で、必ず結論から述べてください。
3.  専門用語を使用する場合は、必ずその直後にカッコ書きで簡単な説明を加えてください。
4.  コードブロックには、必ず言語名（例: `python`）を指定してください。
5.  出力の最後には、常に関連するトピックを3つ提案してください。
6.  最後に、学習した内容の要約と、次に取り組むべきステップを提案する。

### 3.2.7  `Examples`の決定:
- AIに明確な行動基準を示すため、良いコード例と悪いコード例の両方を必ず含めてください。

### 3.2.8  `品質基準`の決定:
- ルールの品質を評価する基準を明確に定義します。

### 3.2.9  `関連ルール`の決定:
- 他のルールファイルとの関連性を定義し、必要に応じて@file記法で参照します。

## ステップ4: 記述方法の統一
### 4.1 記述ガイドライン
- **明確性**: 曖昧な表現を避け、具体的な指示を記述
- **具体性**: 抽象的な概念ではなく、実装可能な内容を記述
- **一貫性**: 用語や記法を統一
- **簡潔性**: 冗長な説明を避け、要点を簡潔に記述
- **ファイル参照記法**:（@file記法）
    他のルールファイルを参照する際は、以下の記法を使用：
     - `@file`の前には必ず説明文を配置
     - ファイル名は正確に記述（拡張子`.mdc`を含む）
     - インデントを適切に設定（説明文の下に配置）
     - 複数のファイルを参照する場合は、それぞれに`@file`記法を使用
>```markdown
>- 説明文
>  @file filename.mdc
>```
### 4.2 セクション名の統一
- **階層**: 適切な階層構造を使用（#, ##, ###）
- **内容**: セクションの内容を明確に表現
- **一貫性**: 同じレベルのセクションは同じ命名パターンを使用

# 品質基準

## 📋 基本構成チェック（必須項目）
- [ ] **YAMLフロントマターが正しく記述されているか（必須）**
- [ ] **`description`が120文字以内で具体的かつ明確か（必須）**
- [ ] **`globs`パターンが適切に設定されているか（Auto Attachedの場合）**
- [ ] **`ruleType`が目的に合致しているか（必須）**
- [ ] **`tags`が適切に分類されているか（必須）**
- [ ] **`version`がセマンティックバージョニングで記述されているか（必須）**
- [ ] **`priority`が設定されているか（競合時の優先度）**
- [ ] **YAML構文が正しいか（クォーテーション、インデント、コロン）**

## 🎯 内容品質チェック
- [ ] 原則セクションに「ルール名!!!!」の呼びかけが含まれているか
- [ ] `Persona`が明確に定義されているか
- [ ] `Context`が適用状況を正確に説明しているか
- [ ] `Chain of Thought`が段階的な思考プロセスを示しているか
- [ ] `Requirements`が番号付きリストで具体的に記述されているか
- [ ] `Examples`に良い例と悪い例の両方が含まれているか
- [ ] コードサンプルが実装可能で正確か

## 🔧 技術的品質チェック
- [ ] エラーケースやエッジケースが考慮されているか
- [ ] ベストプラクティスが明示されているか
- [ ] パフォーマンスやセキュリティの考慮があるか
- [ ] 型安全性やエラーハンドリングが含まれているか
- [ ] 既存のコードベースとの整合性が保たれているか

## 📚 ドキュメント品質チェック
- [ ] 用語の定義が明確か
- [ ] 専門用語に説明が付いているか
- [ ] セクション構造が論理的で分かりやすいか
- [ ] インデントとフォーマットが統一されているか
- [ ] 日本語の表記が統一されているか

## 🔗 関連性と統合（推奨項目）
- [ ] 関連ルールへの参照（@file記法）が適切に設定されているか
- [ ] 既存のルールとの重複や競合がないか
- [ ] ルール間の依存関係が明確か
- [ ] プロジェクト全体のルール体系に適合しているか

## 🛠️ 運用と保守（推奨項目）
- [ ] トラブルシューティングセクションが含まれているか
- [ ] よくある質問（FAQ）が記載されているか
- [ ] 更新履歴や変更ログが管理されているか
- [ ] バックワードコンパチビリティが考慮されているか

## 🎨 ユーザビリティ（推奨項目）
- [ ] 初心者でも理解できる説明になっているか
- [ ] 実践的な使用例が豊富に含まれているか
- [ ] 視覚的な要素（図表、リスト）が適切に使用されているか
- [ ] 検索しやすいキーワードが含まれているか

## 📈 拡張性と将来性（推奨項目）
- [ ] 将来の機能追加を考慮した設計になっているか
- [ ] 設定可能なパラメータが適切に定義されているか
- [ ] 異なるプロジェクトでも再利用可能な汎用性があるか
- [ ] バージョンアップ時の移行ガイドが考慮されているか

## ✅ 最終確認（推奨項目）
- [ ] ルール全体を読み直して一貫性を確認したか
- [ ] 実際のプロジェクトでテストしたか
- [ ] 他の開発者にレビューしてもらったか
- [ ] ドキュメントの完成度を自己評価したか（目標：90%以上）

---

# 📝 ルールサンプル

## ✅ 良いルールの例

```yaml
---
description: "Reactコンポーネントファイル(*.tsx)において、'useState'フックが複雑になった場合に'useReducer'へのリファクタリングを提案する"
globs:
  - "src/components/**/*.tsx"
  - "src/app/**/*.tsx"
alwaysApply: false
ruleType: Auto Attached
tags:
  - react
  - hooks
  - refactoring
  - performance
priority: 2
version: "1.0.0"
triggers:
  - useStateが複雑
  - 状態管理の改善
  - リファクタリング
---

# 原則:
- このファイルを参照したら、`「useReducer提案!!!!」`とさけんでください。読む人が楽しい気分になります。
- パフォーマンスと可読性を最優先に考える
- 既存のコードを壊さないことを最優先する

# ルール名:
- useState to useReducer リファクタリング提案

# Persona:
- あなたはReactの状態管理の専門家で、複雑なuseStateをuseReducerに変換するエキスパートです。コードの可読性と保守性を向上させることを使命としています。

# Context:
- useStateが3つ以上使用されている場合
- 状態の更新ロジックが複雑になっている場合
- 関連する状態が複数存在する場合

# Chain of Thought:
1. 現在のuseStateの使用状況を分析する
2. 状態間の関連性を特定する
3. 適切なreducer関数を設計する
4. アクションタイプを定義する
5. 段階的にリファクタリングを提案する

# Requirements:
1. 必ず既存の機能を維持することを確認してください
2. 段階的な移行手順を提示してください
3. パフォーマンスの改善点を説明してください
4. テストケースの更新方法も含めてください
5. エラーハンドリングの改善も提案してください

# 品質基準
- [ ] **sample**
- [ ] **sample**
- [ ] **sample**
- [ ] **sample**
- [ ] **sample**

# Examples:

## 良い例
```typescript
// Before: 複雑なuseState
const [name, setName] = useState('');
const [email, setEmail] = useState('');
const [isValid, setIsValid] = useState(false);
const [errors, setErrors] = useState({});

// After: useReducer
interface FormState {
  name: string;
  email: string;
  isValid: boolean;
  errors: Record<string, string>;
}

type FormAction = 
  | { type: 'SET_FIELD'; field: string; value: string }
  | { type: 'SET_ERRORS'; errors: Record<string, string> }
  | { type: 'VALIDATE' };

const formReducer = (state: FormState, action: FormAction): FormState => {
  switch (action.type) {
    case 'SET_FIELD':
      return { ...state, [action.field]: action.value };
    case 'SET_ERRORS':
      return { ...state, errors: action.errors };
    case 'VALIDATE':
      return { ...state, isValid: Object.keys(state.errors).length === 0 };
    default:
      return state;
  }
};
```

## 悪い例
```typescript
// 状態が散らばっている
const [user, setUser] = useState(null);
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);

// 関連する状態が分離されている
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
// これらは統合すべき
```

# 品質基準:
- パフォーマンスが向上しているか
- コードの可読性が改善されているか
- テストが容易になっているか
- エラーハンドリングが適切か

# 関連ルール:
- React Hooks ベストプラクティス
  @file react-hooks-best-practices.mdc
- 状態管理パターン
  @file state-management-patterns.mdc
```

## ❌ 悪いルールの例

```yaml
---
description: "Reactのルール"
globs:
  - "*.tsx"
alwaysApply: true
ruleType: Always
tags:
  - react
priority: 1
version: "1.0"
---

# 原則:
- Reactを使う

# ルール名:
- Reactルール

# Persona:
- React開発者

# Context:
- Reactを使う時

# Chain of Thought:
- Reactのことを考える

# Requirements:
- Reactを使う
- コンポーネントを作る

# Examples:
- 良い例: Reactを使う
- 悪い例: Reactを使わない
```

このサンプルにより、良いルールと悪いルールの違いが明確になり、実践的なルール作成の参考になります。



---
description: 
globs: 
alwaysApply: false
---
# 原則:
- このファイルを参照したら、`「ヘッダーメンテナンス!!!!」`とさけんでください。読む人が楽しい気分になります。
- 可読性の最優先: 誰が見ても理解しやすいコードを目指します。
- 型安全性の徹底: TypeScriptを活用し、Propsや状態を厳密に型定義します。
- 責務の明確な分離: 各コンポーネントが持つ役割を単一に保ちます。

# ルール名:
- ヘッダーメンテナンス設計パターン

# Persona:
- あなたはReact/Next.jsのレイアウト設計の専門家で、可読性と保守性を重視したヘッダーコンポーネントの設計エキスパートです。型安全性とコンポーネント分割のベストプラクティスを実践し、開発者が直感的に理解できるヘッダー設計を提供します。

# Context:
- ページタイプに応じてヘッダーの内容を動的に変更したい場合
- リストタイトル、登録ボタン、パンくずリストなどを状況に応じて表示したい場合
- 複数のページで共通のヘッダーパターンを使用したい場合
- 既存のModernLayout.tsxとModernHeader.tsxを拡張する場合

# Chain of Thought(明確な思考プロセス):
1. ページの要件を分析し、必要なヘッダー要素を特定する
2. 共通パターンを抽出し、再利用可能なコンポーネントを設計する
3. 型定義を作成し、型安全性を確保する
4. コンポーネントを適切に分割し、責務を明確にする
5. デフォルト値とオプションを設定し、柔軟性を確保する
6. 実装例を作成し、使用方法を明確にする

# Requirements(網羅的な要件):
1. 必ずTypeScriptの型定義を作成し、型安全性を確保してください
2. コンポーネントは200行以下に抑え、必要に応じて分割してください
3. Propsによる制御を基本とし、デフォルト値を適切に設定してください
4. 既存のModernLayout.tsxとの整合性を保ってください
5. エラーハンドリングとローディング状態を考慮してください
6. アクセシビリティ（aria-label等）を適切に実装してください
7. レスポンシブデザインに対応してください
8. パフォーマンスを考慮し、不要な再レンダリングを避けてください

# 品質基準:
- [ ] 型定義が完全で、型安全性が確保されているか
- [ ] コンポーネントが200行以下で、適切に分割されているか
- [ ] Propsの設計が直感的で、デフォルト値が適切か
- [ ] 既存のレイアウトシステムとの整合性が保たれているか
- [ ] エラーハンドリングとローディング状態が実装されているか
- [ ] アクセシビリティが考慮されているか
- [ ] レスポンシブデザインに対応しているか
- [ ] パフォーマンスが最適化されているか
- [ ] テストが容易な設計になっているか
- [ ] ドキュメントが充実しているか

# 関連ルール:
- Next.js プロジェクトにおける page.tsx の構造・分割ルール
  @file page-tsx-systematic-rules.mdc
- API呼び出しの実装パターン
  @file api.mdc

# 設計戦略:

## 1. 状態管理の戦略
### Context API vs Props Drilling vs 外部状態管理の選択基準
- `Context API`: ヘッダー固有の状態（テーマ、レイアウト設定）に使用
- `Props Drilling`: ページ固有の設定（タイトル、アクション）に使用
- `Zustand/Redux`: グローバル状態（ユーザー情報、認証状態）に使用

### ヘッダー固有の状態とグローバル状態の分離方針
- `ヘッダー固有`: 表示/非表示、アニメーション状態、レイアウト設定
- `グローバル状態`: ユーザー情報、認証状態、アプリケーション設定
- `分離原則`: ヘッダーコンポーネントはグローバル状態に直接依存しない

## 2. 拡張性の確保
### 新しいヘッダーパターンを追加する際の手順
1. `型定義の拡張`: `HeaderConfig`インターフェースに新しいプロパティを追加
2. `コンポーネント作成`: 新しいパターン専用のコンポーネントを作成
3. `ファクトリー関数`: パターンに応じたコンポーネントを返すファクトリー関数
4. `ドキュメント更新`: 新しいパターンの使用方法をドキュメント化

### カスタムフックによる状態ロジックの分離
- `useHeaderState`: ヘッダーの表示状態管理
- `useHeaderActions`: アクションボタンのロジック管理
- `useHeaderNavigation`: ナビゲーション関連のロジック
- `useHeaderTheme`: テーマ関連の設定管理

### Composition パターンの導入（スロットの活用）
- `スロット設計`: 特定の領域にコンポーネントを直接注入する仕組み
- `表現力向上`: Propsによる制御では対応できない複雑なレイアウトに対応
- `柔軟性確保`: 利用側で自由にカスタム要素を定義して埋め込み可能
- `デフォルト値`: スロットが指定されない場合の適切なフォールバック

### テーマやスタイルのカスタマイズ可能性
- `CSS変数`: テーマカラーやサイズの動的変更
- `Tailwind設定`: カスタムクラスの定義
- `コンポーネントプロパティ`: スタイルの上書き機能
- `テーマプロバイダー`: アプリケーション全体でのテーマ統一

## 3. 開発体験の向上

### Storybook等でのコンポーネントカタログ化
- `ストーリー作成`: 各ヘッダーパターンのストーリー
- `インタラクション`: アクションボタンの動作確認
- `レスポンシブ`: 各ブレークポイントでの表示確認
- `アクセシビリティ`: スクリーンリーダー対応の確認

### デバッグ用のdev toolsやログ出力
- `開発モード`: 詳細なログ出力とデバッグ情報
- `パフォーマンス計測`: レンダリング時間の計測
- `状態追跡`: ヘッダー状態の変更履歴
- `エラー検出`: 不正な設定の検出と警告

### 開発者向けのwarning機能（不正な組み合わせの検出）
- `型チェック`: TypeScriptによる厳密な型チェック
- `実行時チェック`: 不正なプロパティの組み合わせ検出
- `コンソール警告`: 開発者への適切な警告メッセージ
- `エラー境界`: 予期しないエラーの適切な処理

## 4. 実行時の考慮事項

### 動的インポートによるバンドルサイズ最適化
- `遅延読み込み`: 使用されないヘッダーパターンの遅延読み込み
- `コード分割`: パターン別のコード分割
- `プリロード`: 頻繁に使用されるパターンのプリロード
- `キャッシュ戦略`: 適切なキャッシュ設定

### メモ化戦略（useMemo/useCallback）の指針
- `重い計算`: 複雑なスタイル計算のメモ化
- `イベントハンドラー`: アクションボタンのコールバックメモ化
- `条件分岐`: 表示条件の計算結果メモ化
- `依存関係`: 適切な依存関係の設定

### エラーバウンダリーの設置
- `ヘッダー専用`: ヘッダーコンポーネント専用のエラーバウンダリー
- `フォールバック`: エラー時の適切なフォールバック表示
- `エラー報告`: エラー情報の適切な収集と報告
- `復旧機能`: エラーからの自動復旧機能

## 5. 運用面での配慮

### A/Bテストに対応した切り替え機能
- `実験設定`: ヘッダーパターンの実験設定
- `トラッキング`: ユーザー行動の追跡
- `動的切り替え`: 実験結果に基づく動的切り替え
- `結果分析`: 実験結果の分析とレポート

### 段階的リリース（feature flag）への対応
- `フラグ管理`: 機能フラグの適切な管理
- `段階的展開`: ユーザーグループ別の段階的展開
- `ロールバック`: 問題発生時の迅速なロールバック
- `監視`: 機能フラグの状態監視

### 使用状況の分析・モニタリング
- `使用統計`: 各ヘッダーパターンの使用頻度
- `パフォーマンス監視`: レンダリング時間とメモリ使用量
- `エラー監視`: エラー発生率と種類の監視
- `ユーザー行動`: ヘッダー操作のユーザー行動分析


# 実装ガイドライン:
## 1. コンポーネント分割の原則
- `単一責任`: 各コンポーネントは1つの責務のみを持つ
- `再利用性`: 複数のページで使用できる汎用的な設計
- `型安全性`: TypeScriptの型定義を徹底する
- `デフォルト値`: 指定されない場合の適切なデフォルトを設定
## 2. パフォーマンス最適化
- `メモ化`: 不要な再レンダリングを防ぐ
- `遅延読み込み`: 大きなコンポーネントは必要時のみ読み込み
- `バンドル分割`: 動的インポートを活用
## 3. アクセシビリティ
- `セマンティックHTML`: 適切なHTMLタグを使用
- `ARIA属性`: スクリーンリーダー対応
- `キーボードナビゲーション`: キーボードでの操作をサポート
## 4. レスポンシブデザイン
- `モバイルファースト`: モバイルを基準とした設計
- `ブレークポイント`: 適切なブレークポイントの設定
- `フレキシブルレイアウト`: 画面サイズに応じた柔軟な配置









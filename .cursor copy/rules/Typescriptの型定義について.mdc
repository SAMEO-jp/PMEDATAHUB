# TypeScript型定義ガイドライン

## 1. 基本的な型定義の使い分け

### 1.1 interface はオブジェクト構造に使用する
**ルール説明**
オブジェクトのプロパティ構造（形）を表す場合は、interface を使う。

**適用方法**
```typescript
interface User { 
  id: number; 
  name: string;
  email: string;
}
```

**適用範囲**
- データモデル定義（User, Article など）
- React Props
- APIレスポンスの構造定義
- データベーステーブル構造

**メリット**
- 継承（extends）が使える
- 宣言のマージが可能（ライブラリ拡張に便利）
- コード補完が強力で可読性が高い

**考慮事項**
- ユニオンや複雑な型演算には不向き
- 拡張できるが、柔軟すぎてバグの温床になることもある

### 1.2 type はユニオン型・プリミティブ型に使用する
**ルール説明**
複数の型を組み合わせたり、プリミティブ型に別名をつける場合は type を使う。

**適用方法**
```typescript
type Status = 'loading' | 'success' | 'error';
type ID = string;
type ApiResponse<T> = {
  data: T;
  status: Status;
};
```

**適用範囲**
- ユニオン型（選択肢の定義）
- プリミティブの別名
- タプル、条件付き型、Mapped Type など
- ジェネリック型定義

**メリット**
- 表現力が高い（型演算が可能）
- 関数型やユーティリティ型との相性が良い

**考慮事項**
- 再定義やマージができない（イミュータブル）
- 同じ名前の拡張ができない（上書き不可）

## 2. プロジェクト固有の型定義ルール

### 2.1 データベース関連の型定義
**ルール説明**
データベーステーブルに対応する型定義は、テーブル名をプレフィックスとして使用する。

**適用方法**
```typescript
// パレット関連のテーブル
interface PaletStatus {
  palet_status_id: number;
  palet_status_name: string;
  palet_status_notes?: string;
  created_at: Date;
  updated_at: Date;
}

// BOM関連のテーブル
interface BomItem {
  bom_item_id: number;
  bom_item_name: string;
  bom_item_quantity: number;
  created_at: Date;
  updated_at: Date;
}
```

**命名規則**
- テーブル名をプレフィックスとして使用
- `created_at`, `updated_at`は共通で使用
- オプショナルなフィールドは`?`を使用

### 2.2 API関連の型定義
**ルール説明**
APIレスポンスとリクエストの型定義は明確に分離する。

**適用方法**
```typescript
// リクエスト型
interface CreateUserRequest {
  name: string;
  email: string;
  password: string;
}

// レスポンス型
interface UserResponse {
  id: number;
  name: string;
  email: string;
  created_at: Date;
}

// エラーレスポンス型
interface ApiError {
  message: string;
  code: string;
  details?: Record<string, any>;
}
```

### 2.3 ReactコンポーネントのProps定義
**ルール説明**
React のコンポーネント Props は interface を基本とする。

**適用方法**
```typescript
interface Props { 
  title: string; 
  onClick: () => void;
  children?: React.ReactNode;
  className?: string;
}

// または
interface ComponentProps {
  data: UserResponse[];
  loading: boolean;
  onRefresh: () => void;
}
```

**適用範囲**
- 関数コンポーネントの Props
- 再利用される UI コンポーネントの型定義

**メリット**
- 自動補完が効きやすい
- 継承・拡張が簡単（HOCなどとの組み合わせ）

**考慮事項**
- Propsがユニオンや条件付き型を含む場合、type を検討してもよい

## 3. 高度な型定義パターン

### 3.1 カスタムフックのジェネリクス対応
**ルール説明**
型を使い回せるように、カスタムフックには <T> を使ったジェネリック定義を行う。

**適用方法**
```typescript
function useFetch<T>(url: string): { 
  data: T | null;
  loading: boolean;
  error: string | null;
}

function useApiQuery<T, P = void>(
  endpoint: string,
  params?: P
): {
  data: T | null;
  loading: boolean;
  error: ApiError | null;
  refetch: () => void;
}
```

**適用範囲**
- API 呼び出し（useFetch, useQuery など）
- データ変換フック（useMap, useForm など）
- 状態管理フック

**メリット**
- 呼び出し側で自由に型を指定できる
- 型安全なデータ取得・状態管理が可能
- 再利用性が高い

**考慮事項**
- T に制約を付けたい場合は `T extends` を使う
- 型のままでは使えないロジックがある場合、汎化しすぎない工夫が必要

### 3.2 ユーティリティ型の活用
**ルール説明**
TypeScriptの組み込みユーティリティ型を活用して型定義を効率化する。

**適用方法**
```typescript
// Partial: すべてのプロパティをオプショナルにする
type PartialUser = Partial<User>;

// Pick: 特定のプロパティのみを選択
type UserBasicInfo = Pick<User, 'id' | 'name' | 'email'>;

// Omit: 特定のプロパティを除外
type UserWithoutPassword = Omit<User, 'password'>;

// Record: キーと値の型を指定したオブジェクト型
type StatusMap = Record<string, Status>;

// ReturnType: 関数の戻り値の型を取得
type ApiResponse = ReturnType<typeof fetchUser>;
```

### 3.3 条件付き型とテンプレートリテラル型
**ルール説明**
条件付き型とテンプレートリテラル型を活用して動的な型定義を行う。

**適用方法**
```typescript
// 条件付き型
type NonNullable<T> = T extends null | undefined ? never : T;

// テンプレートリテラル型
type ApiEndpoint = `/api/${string}`;
type ImagePath = `/photos/projects/${string}/images/${string}`;

// 条件付き型の応用
type EventHandler<T> = T extends 'click' ? MouseEvent : 
                       T extends 'keydown' ? KeyboardEvent : 
                       Event;
```

## 4. 型定義の配置とファイル構成

### 4.1 型定義ファイルの配置
**ルール説明**
型定義は用途に応じて適切な場所に配置する。

**配置パターン**
```
src/
├── types/
│   ├── api.ts          # API関連の型定義
│   ├── db.ts           # データベース関連の型定義
│   ├── components.ts   # コンポーネント関連の型定義
│   └── index.ts        # エクスポート用
├── components/
│   └── ComponentName/
│       ├── ComponentName.tsx
│       └── types.ts    # コンポーネント固有の型定義
└── hooks/
    └── useCustomHook.ts
```

### 4.2 型定義のエクスポート
**ルール説明**
型定義は適切にエクスポートして再利用性を高める。

**適用方法**
```typescript
// types/index.ts
export * from './api';
export * from './db';
export * from './components';

// または個別にエクスポート
export type { User, UserResponse } from './api';
export type { PaletStatus, BomItem } from './db';
```

## 5. 型安全性の確保

### 5.1 厳密な型チェック
**ルール説明**
TypeScriptの厳密な型チェックを活用してバグを防ぐ。

**設定例**
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  }
}
```

### 5.2 型ガードの活用
**ルール説明**
実行時の型チェックを行う型ガードを活用する。

**適用方法**
```typescript
// 型ガード関数
function isUser(obj: any): obj is User {
  return obj && typeof obj.id === 'number' && typeof obj.name === 'string';
}

// 型ガードの使用
function processUser(data: unknown) {
  if (isUser(data)) {
    // この中ではdataはUser型として扱える
    console.log(data.name);
  }
}
```

## 6. パフォーマンスとメンテナンス

### 6.1 型定義の最適化
**ルール説明**
型定義は必要最小限に保ち、パフォーマンスを考慮する。

**考慮事項**
- 不要な型定義は削除する
- 大きな型定義は分割する
- 循環参照を避ける

### 6.2 型定義のドキュメント化
**ルール説明**
複雑な型定義には適切なコメントを付ける。

**適用方法**
```typescript
/**
 * ユーザー情報を表す型定義
 * @property id - ユーザーID（一意）
 * @property name - ユーザー名
 * @property email - メールアドレス
 */
interface User {
  /** ユーザーID（一意） */
  id: number;
  /** ユーザー名 */
  name: string;
  /** メールアドレス */
  email: string;
}
```

## 7. プロジェクト固有の制約とベストプラクティス

### 7.1 データベースカラム名の命名規則
- テーブル名をプレフィックスとして使用（例：`palet_status_notes`）
- `created_at`, `updated_at`は共通で使用
- オプショナルなフィールドは`?`を使用

### 7.2 コンポーネント分割時の型定義
- コンポーネントが大きくなった場合は、`component`フォルダを作成
- 型定義は適切に分割して再利用性を高める

### 7.3 型定義の一貫性
- プロジェクト全体で一貫した命名規則を使用
- 既存の型定義との整合性を保つ
- 新しい型定義を追加する際は既存のパターンに従う
考慮事項

T に制約を付けたい場合は T extends を使う

型のままでは使えないロジックがある場合、汎化しすぎない工夫が必要
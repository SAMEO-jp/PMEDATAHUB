---
description:
globs:
alwaysApply: false
---
Serena MCPサーバーのコマンド一覧と役割
Serenaは、LLM（大規模言語モデル）をコードベース上でエージェントとして機能させるための強力なコーディングエージェント・ツールキットです

。IDEのようにシンボルレベルでコード構造を解析・編集するセマンティックな機能を提供し、大規模プロジェクトでも効率的なコード操作を可能にします

。オープンソースで無料公開されており、既存のLLM（例えばAnthropic ClaudeやChatGPTなど）の能力を拡張できます

。Serenaは**モデルコンテキストプロトコル（MCP）**という標準に対応したサーバーとして動作し、Claude CodeやVSCode拡張、Gemini CLIなど様々なクライアントから利用できます
github.com
。以下に、Serenaが提供する主要なコマンド（ツール）について、その概要・役割、典型的な使用例、目的（ユースケース）を整理します。
Serena MCPサーバーのコマンド一覧
コマンド名	概要・役割 (Overview)	典型的な使用例 (Usage)	主な用途・ユースケース (Purpose)
list_dir	指定したディレクトリ内のファイルやサブディレクトリを一覧表示するコマンドです（必要に応じて再帰的に検索可能）

。結果はディレクトリ名とファイル名のリストをJSON形式で返します

。	プロジェクト開始時にrelative_path="."（プロジェクトルート）を指定して全体のディレクトリ構成を把握する、といった用途で使われます。	プロジェクト内のファイル構造把握・ナビゲーション。特に初期状態でのフォルダ内容確認や、特定ディレクトリ下のファイル一覧取得に利用。
find_file	ワイルドカード（*や?）を含むファイル名パターンで、指定ディレクトリ以下のファイルを検索します

。該当する全てのファイルパスをJSON配列で取得でき、効率的なファイル管理に役立ちます

。	例：file_mask="*.py"としてプロジェクト中のPythonファイルを一覧したり、file_mask="*Test.java"でテストクラスファイルのみを探す、といった使い方ができます。	ファイル検索・ナビゲーション。大規模プロジェクトで特定の名前パターンを持つファイル（拡張子や接頭辞など）を素早く見つけるのに有用。
replace_regex	正規表現パターンにマッチするテキストを置換するコマンドです。Pythonスタイルの正規表現を用い、複数行にまたがるテキストでも置換できます

。シンボル単位の編集が難しい場合に、柔軟なテキスト置換手段を提供します

。	例：関数名の一括変更時に直接シンボルをリネームできないケースでは、regex="oldFunctionName"→repl="newFunctionName"のように正規表現でコード全体を置換します。	コード編集（テキストベースのリファクタリング）。シンボルツールで対応できない広範な変更や複数行に及ぶ修正を行う際に使用。
search_for_pattern	プロジェクト全体から指定した正規表現パターンにマッチする箇所を検索するコマンドです

。コードファイルに限定するか全ファイルを対象にするか選択でき、前後の文脈行数も指定可能です


。検索結果はマッチした行を含むコンテキスト付きでJSON形式で返されます

。	コード内で特定の文字列や正規表現に合致する箇所を全て探したい時に使用します。例えばpattern="TODO"で残課題のコメント箇所を一覧したり、特定のログ出力文字列をgrep的に検索する用途です。	コード検索・調査。関数呼び出し箇所の全文検索や特定文字列の出現箇所確認など、シンボリック検索では見つからないパターンを探す際に利用。
restart_language_server	コード解析のバックエンドである言語サーバー（LSP）を再起動するコマンドです。プロジェクト外部で直接ファイルを編集した場合など、言語サーバー上の情報と実際のコードが不整合になる際に再同期を図ります

。	エディタやGitでコードを更新した後にSerena経由で検索・編集する前に、本コマンドで言語サーバーを再起動し最新状態に更新するといった使い方が推奨されます。	環境メンテナンス。言語サーバーによるシンボル情報の正確性を保つための再初期化。コード変更の追従や不具合時の復旧に利用。
get_symbols_overview	指定したファイルまたはディレクトリ直下の各ファイルについて、最上位レベルのシンボル（クラス、関数など）の一覧を取得します


。各ファイル内で定義されている主要シンボル名と種類をJSON形式で返し、コード構造の概要把握に役立ちます


。	大きなプロジェクトで、新しいディレクトリ配下にどんなクラスや関数があるかをざっと知りたい場合に使用します。実行すると各ファイルに含まれるトップレベル定義（例：クラス名や主要関数名）が一覧表示されます。	コード構造の把握・要約。オンボーディング直後にプロジェクト全体の構造を概観したり、特定モジュール内の主要なクラス/メソッドを調査するのに有用。
find_symbol	与えた名前（またはその一部）にマッチするシンボル（クラス、関数、変数など）をコードベースから検索します

。言語サーバーのシンボル情報を利用し、シンボルツリー内のパス指定（例：「クラス名/メソッド名」）で検索することも可能です


。検索結果はシンボルの定義位置や種別等のメタデータを含むJSONで返されます。	例：「name_path=\"UserService/get*\"」のように指定して、UserServiceクラス内の名前が「get」で始まるメソッドを全て探す、といった使い方ができます。またrelative_pathを指定すれば検索範囲を特定ファイルやディレクトリ内に絞れます。	コードナビゲーション（シンボリック検索）。関数やクラスの定義箇所を素早く見つけたいときや、大まかな名前でシンボルを検索したい場合に使用。IDEの「シンボル検索」に相当する機能。
find_referencing_symbols	指定したシンボルを参照している他のシンボルを検索します

。たとえば、あるクラスを継承しているサブクラスや、ある関数を呼び出している箇所のシンボルを洗い出すことが可能です


。結果は参照しているシンボルの情報と、その周辺のコードスニペットが含まれたリストとしてJSON出力されます

。	ある関数がプロジェクト内でどこから呼ばれているか調べたい時に使用します。関数定義のシンボル（名前とファイル）を指定すると、その関数を呼び出している全ての関数やメソッドの一覧が取得できます。	コード影響範囲の分析・リファクタリング支援。機能変更時に影響を受ける箇所を洗い出したり、クラスの継承関係やメソッドの呼び出し関係を把握するのに有用。
replace_symbol_body	指定したシンボル（例：関数やメソッド）の本体部分全体を、新しいコードで置き換えるコマンドです

。言語サーバーで特定したシンボルの範囲を丸ごと差し替えるため、実装を一括変更できます。インデントは元の構造に合わせ自動調整されるため、コードを記述する際は先頭行以降は相対インデントで記述すれば適切に挿入されます


。	既存の関数の実装ロジックを全面的に書き換える場合に使います。まずfind_symbolで対象シンボルを特定し、そのname_pathと新しいbodyコードを渡して本コマンドを呼ぶことで、関数内容を丸ごと更新できます。	コード編集（実装の差し替え）。関数・メソッドのリファクタリングやアルゴリズム変更など、大きな実装変更を行う際に使用。IDEにおける「関数の中身を置換」に相当する操作を自動化。
insert_after_symbol	指定したシンボルの定義直後に、新たなコード片を挿入するコマンドです

。たとえばある関数のすぐ後に新しい関数を追加するといった操作が自動化できます。挿入されるコードは対象シンボルのインデントレベルに合わせて自動整形されます


。	例：既存のクラス定義の直後に新しいクラスや関数を追加したい場合に利用します。name_pathに基準とするシンボル（例：クラス名）を指定し、bodyに追加するコードを与えると、そのシンボルの直後にコードが挿入されます。	コード編集（新規コードの追加）。既存コードの直後に関連する処理やクラスを追記する際に使用。作業効率を上げ、一貫したインデントでコードを継ぎ足すのに便利。
insert_before_symbol	指定したシンボルの定義直前（前方）に、新たなコード片を挿入します

。ファイル内で特定シンボルよりも前にコードを追加したい場合に用いられ、例えばファイル先頭のimport文追加などにも使えます

。このコマンドでもインデントは自動調整されます

。	例：ファイルの冒頭付近に初期化コードやインポートを追加する場合に、最初のクラス定義シンボルをname_pathに指定してbodyにコードを書くことで、そのシンボルより前の位置にコードを挿入できます。	コード編集（コードの挿入）。既存定義より前にコードを差し込む必要がある場合に使用。モジュール冒頭へのインポート追加や、クラス定義前にヘルパー関数を挿入するケースなどで役立つ。
write_memory	プロジェクト専用の「メモリ」ストアに情報を書き込むコマンドです

。任意の名前(memory_name)と内容(content)を指定してメモを保存でき、内容はMarkdown形式で短く要点をまとめることが推奨されています


。1つの大きなメモより、トピック別に分割した複数の小メモを残す方が効果的とされています

。	Serenaのオンボーディング処理実行時や、会話中に得た重要な知見を後で再利用するために使用します

。例えば「ビルド手順」や「主要設定項目」などをメモ名にして簡潔な説明を保存しておき、後で参照できます。	プロジェクト知識の蓄積・共有。AIアシスタントが得た情報や結論をプロジェクトメモリに記録し、後続のタスクで再利用することで一貫性を保つ目的。特に長期プロジェクトでの知識ベース構築に有用。
read_memory	write_memoryで保存されたメモを名前で指定して読み出すコマンドです

。該当メモファイルの内容を取得しますが、現在のタスクに関連ある場合にのみ読むべきとされています

。同じメモを1つのセッションで何度も読むのは避け、メモ名から必要性を判断する設計になっています

。	例：新しいタスクに取り組む際、「以前保存した設計方針のメモが役立ちそうだ」と判断した場合に、そのメモ名を指定して内容を読み出します。これにより、事前に蓄えたプロジェクト知識をLLMが再度利用できます。	プロジェクト知識の参照。過去に記録した重要情報（要件、設計メモ、制約事項など）を必要に応じて呼び出し、現在のアシスタントの回答やコード編集方針に反映させる用途。
list_memories	現在プロジェクトのメモリストアに保存されている全メモの一覧を取得するコマンドです。保存済みメモの名前リストがJSON形式で返され、後でread_memoryで個別内容を読む際の参考になります

。	プロジェクトにどんなメモが蓄積されているか確認したいときに使用します。特にメモ名から内容を推測できるように命名されているため、一覧を見ることで必要なメモを特定できます。	メモリ管理。プロジェクト知識の全体像を把握し、重複や不足を確認する用途。また、必要な情報を見落とさないようメモ名を確認して関連知識を引き出す助けとします。
delete_memory	プロジェクトのメモリストアから、指定したメモを削除するコマンドです

。古くなった情報や不要になったメモをユーザーが明示的に希望した場合にのみ使われる想定で、誤って有用な知識を消してしまわないよう慎重な運用が求められます

。	例：メモ「API仕様」が古いバージョンの情報で誤解を招く恐れがあるため、ユーザーの指示でmemory_file_name="API仕様"を削除するといったケースです。通常はユーザーから「このメモはもう不要」と言われた場合にのみ実行します。	メモリ管理・クリーンアップ。不正確または陳腐化したプロジェクト知識を消去し、今後参照しないようにする目的。ユーザーの要求に応じて行われ、プロジェクト知識の最新性を保つための手段。
activate_project	Serenaにプロジェクトを認識・アクティブ化させるコマンドです

。プロジェクト名またはディレクトリパスを指定すると、そのプロジェクトが「現在の作業対象」として登録されます

。これにより以降のツール操作がそのプロジェクトのコードベースに対して行われるようになります。	初回に作業ディレクトリでSerenaを使い始める際、projectにカレントディレクトリ（プロジェクトパス）を指定してこのコマンドを呼び出します。これによって言語サーバーが起動され、以降の検索・編集系コマンドがこのプロジェクト内で動作します。	プロジェクト管理（コンテキスト設定）。扱うコードベースの切り替えや初期設定に用いられ、複数プロジェクトを扱う場合のコンテキスト誤り防止、またプロジェクト毎の設定適用などを目的とします。
check_onboarding_performed	指定プロジェクトについてオンボーディング処理が既に済んでいるかを確認するコマンドです

。activate_project直後に呼び出し、オンボーディング未実施なら後述のonboardingを行う判断材料とします

。このコマンド自体は成功/未実施といったフラグを返す簡易なチェックです。	Serenaをプロジェクトに接続した直後に実行し、「まだオンボーディングしていない」と判定されたら自動的にonboardingツールを走らせる、といった流れで使われます。逆に既にオンボーディング済なら二重実行を避けそのまま作業に移行します。	ワークフロー制御・初期化チェック。プロジェクトの初期解析を重複して行わないようにし、必要な場合のみオンボーディング処理を開始するための判定に利用。毎回のセッション開始時にプロジェクト状態を確認する役割。
onboarding	プロジェクトの構造や重要タスクを把握するための初期処理（オンボーディング）を実行します

。例えばビルド方法やテストの検出など、プロジェクトに応じた情報収集を段階的に行い、その結果をメモリに記録する手順がガイドされます
github.com
。このコマンドは1つの会話セッションで一度だけ呼ばれ、必要な初期情報を整えます

。	新しいプロジェクトでSerenaを使い始めた最初の段階で実行します。するとSerenaがプロジェクト内の重要ファイル（例: READMEや設定ファイル）を読み、構成やビルド方法を調べて「プロジェクト概要」「ビルド手順」などのメモをwrite_memoryで保存する、といった一連の初期セットアップが対話的に行われます。	プロジェクト分析・初期コンテキスト構築。AIアシスタントがプロジェクトの全体像や重要事項を理解し、以降の開発支援に備えるためのステップ。毎回ゼロから説明を受けずに済むよう、プロジェクト特有の知識を蓄積する目的があります。
think_about_collected_information	コード検索や読み取りを一通り終えた後に、収集した情報が十分か適切かを内省するための思考用コマンドです

。find_symbolやread_fileなどを複数回使って情報を集めたら、このツールを呼び出して不足や無関係な点がないか検討します

。実行するとLLM自身が「得られた情報で問題解決に足りるか？」を考察し、さらなる探索が必要か判断します。	例：あるバグ修正のため関連関数をfind_symbolで探し、実装をread_fileで読んだ後、このツールを使って「収集情報に漏れはないか？」とチェックします。LLMは「まだ関連する設定ファイルを確認していないが重要では？」などと自己分析し、必要なら追加調査を提案します。	AIアシスタントの内省・計画調整。目的のために十分なコンテキストが揃っているか自己評価し、タスクの抜け漏れを減らす狙い

。コード操作の途中段階で行う振り返りステップとして、不要なミスや再作業を防ぎます。
think_about_task_adherence	長い対話や複雑な操作の途中で、現在のタスク方針から逸れていないかを確認するための思考用コマンドです

。特に複数のやり取りを経て状況が変わった場合などに、ここで一度「元の依頼内容と合致した作業をしているか」を点検します

。このツールはコードに変更を加える前に必ず呼ぶべきものとされており

、焦点の再確認と誤解の修正を促します。	例：機能追加の要求に対し下調べや設計議論を重ねた後、コードを書き始める前に本コマンドを実行します。LLMは「依頼はUIの変更だったが、正しくAPIではなくUIコードに着手しようとしているか？」など自己チェックし、タスクから逸れていないか再認識します。	AIアシスタントの内省・タスクフォーカス維持。ユーザーの意図に沿った対応を続けているか確認し、大規模コードベースでの作業中に目的見失いを防ぐ

。コード改変前の安全装置として機能し、的外れな編集を避ける役割を果たします。
think_about_whether_you_are_done	ユーザーの要求を完全に満たせたかを判断するための思考用コマンドです

。タスクが完了したと感じた段階でこのツールを呼び出し、LLM自身に仕上がりを評価させます

。未達成の部分や追加すべき検証がないかを洗い出し、最終回答やコードの提出前に抜け漏れをチェックします。	コーディング作業や回答を一通り終え、「これで完了だろう」と思ったときに実行します。LLMは要求事項を再確認し、「単体テストの更新がまだ」等の残タスクがないか考察します。問題なければ完了と判断し、必要があれば最後の仕上げ作業（例えば変更箇所の要約）に移ります。	AIアシスタントの内省・完了判断。回答やコード修正が要求を満たしているか最終チェックすることで、不十分な成果物の提出を防ぎます

。ユーザーへの返答内容やコミット前に自己レビューする段階として機能します。

補足: MCP（Model Context Protocol）は、AIアシスタントと外部ツール群（サーバー）との連携を標準化するプロトコルです
anthropic.com
。Serena MCPサーバーは上記のようなコード操作ツールや内省用ツールをLLMに提供し、プロジェクト管理からコード編集・検索、思考プロセスの制御まで幅広く支援します。これらにより、LLMエージェントは人間の開発者さながらにプロジェクトを理解し、自律的に作業を進めることが可能になります
github.com
github.com
。
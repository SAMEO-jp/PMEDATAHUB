---
description: 
globs: 
alwaysApply: false
---
# コーディング規約 - Next.js App Router + TypeScript

## 🎯 基本方針
TypeScript、Node.js、Next.js App Router、React、Shadcn UI、Radix UI、Tailwind CSSのエキスパートとして開発を行います。

## 📁 プロジェクト構造
```
src/
├── app/                    # Next.js App Router
│   ├── app_sample/         # 例:app_sample
│   │   ├── page.tsx       # メインページ
│   │   ├── components/    # UIコンポーネント
│   │   ├── hooks/         # カスタムフック
│   │   ├── lib/           # API・ユーティリティ
│   │   ├── types/         # 型定義
│   │   └── utils/         # ヘルパー関数
│   └── api/               # API Routes
├── components/            # グローバルコンポーネント
├── lib/                   # 共有ライブラリ
└── types/                 # グローバル型定義
```

## 🏗️ コードのスタイルと構造

### 基本原則
- **正確な例を用いて、簡潔で技術的な TypeScript コードを書く**
- **関数型と宣言型のプログラミングパターンを使用し、クラスは避ける**
- **コードの重複よりも反復とモジュール化を優先する**
- **補助動詞(isLoading, hasErrorなど)を用いた説明的な変数名を使用する**


## 🏷️ 命名規則

### ディレクトリ・ファイル名
- **ディレクトリ**: ダッシュ付きの小文字（例: `components/auth-wizard`）
- **コンポーネント**: PascalCase（例: `UserProfile.tsx`）
- **フック**: camelCase with `use` prefix（例: `useUserData.ts`）
- **ユーティリティ**: camelCase（例: `dateUtils.ts`）
- **型定義**: PascalCase with `.types.ts` suffix（例: `User.types.ts`）

### 変数・関数名
- **変数**: 説明的な名前（例: `isLoading`, `hasError`, `userData`）
- **関数**: 動詞 + 名詞（例: `fetchUserData`, `handleSubmit`）
- **定数**: UPPER_SNAKE_CASE（例: `API_ENDPOINTS`）

## 🔧 TypeScriptの使用法

### 基本原則
- **すべてのコードにTypeScriptを使用する**
- **列挙型は避け、代わりにconst assertionを使用する**
- **インターフェースを優先し、typeは必要時のみ使用する**

### 型定義の例
```typescript
// インターフェース（推奨）
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}

// 定数オブジェクト（列挙型の代替）
const USER_STATUS = {
  ACTIVE: 'active',
  INACTIVE: 'inactive',
  PENDING: 'pending',
} as const;

type UserStatus = typeof USER_STATUS[keyof typeof USER_STATUS];

// Props型定義
interface ComponentProps {
  data: User[];
  onSelect: (user: User) => void;
  isLoading?: boolean;
}
```

## 🎨 UIとスタイリング

### 使用ライブラリ
- **Shadcn UI**: 基本UIコンポーネント
- **Radix UI**: アクセシブルなプリミティブ
- **Tailwind CSS**: スタイリング

### スタイリング原則
- **モバイルファーストアプローチ**
- **レスポンシブデザインの実装**
- **一貫したスペーシングとカラーパレット**
- **アクセシビリティの考慮**

### コンポーネント例
```tsx
interface ButtonProps {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
}

export function Button({ 
  variant = 'default', 
  size = 'default', 
  children, 
  onClick, 
  disabled 
}: ButtonProps) {
  return (
    <button
      className={cn(
        'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors',
        'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring',
        'disabled:pointer-events-none disabled:opacity-50',
        buttonVariants({ variant, size })
      )}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
}
```

## ⚡ パフォーマンスの最適化

### React Server Components (RSC)
- **Server Componentsを優先使用**
- **Client Componentsは必要最小限に**
- **データ取得はServer Componentsで実行**

### 最適化テクニック
```tsx
// Server Component（推奨）
export default async function UserList() {
  const users = await fetchUsers(); // サーバーサイドで実行
  return <UserTable users={users} />;
}

// Client Component（必要時のみ）
'use client';
export function UserTable({ users }: { users: User[] }) {
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  
  return (
    <div>
      {users.map(user => (
        <UserRow 
          key={user.id} 
          user={user} 
          onSelect={setSelectedUser}
        />
      ))}
    </div>
  );
}
```

### メモ化と最適化
```tsx
// useMemo for expensive calculations
const expensiveValue = useMemo(() => {
  return heavyCalculation(data);
}, [data]);

// useCallback for event handlers
const handleClick = useCallback((id: string) => {
  setSelectedId(id);
}, []);

// React.memo for component memoization
const UserRow = React.memo(({ user, onSelect }: UserRowProps) => {
  return (
    <div onClick={() => onSelect(user)}>
      {user.name}
    </div>
  );
});
```

## 🗄️ データベース操作（SQLite）

### 基本原則
- **データベースファイル**: `data/achievements.db`
- **型安全性**: すべてのクエリに型定義を付与
- **エラーハンドリング**: try-catch文で適切に処理

### データベース操作例
```typescript
// lib/db/db_connection.ts
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';

export async function getDb() {
  return open({
    filename: 'data/achievements.db',
    driver: sqlite3.Database
  });
}

// lib/db/db_CRUD.ts
export async function getUserById(id: string): Promise<User | null> {
  try {
    const db = await getDb();
    const user = await db.get<User>('SELECT * FROM users WHERE id = ?', [id]);
    return user || null;
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
}
```

## 🔄 状態管理

### 基本方針
- **ローカル状態**: useState, useReducer
- **グローバル状態**: Zustand（必要時のみ）
- **サーバー状態**: Server Components + キャッシュ

### Zustand使用例
```typescript
// store/userStore.ts
import { create } from 'zustand';

interface UserStore {
  user: User | null;
  setUser: (user: User | null) => void;
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
}

export const useUserStore = create<UserStore>((set) => ({
  user: null,
  setUser: (user) => set({ user }),
  isLoading: false,
  setIsLoading: (isLoading) => set({ isLoading }),
}));
```

## 🚨 エラーハンドリング

### 基本原則
- **適切なエラーメッセージを表示**
- **ユーザーフレンドリーなエラー処理**
- **ログ出力によるデバッグ支援**

### エラーハンドリング例
```tsx
// コンポーネントレベル
export default function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function fetchUser() {
      try {
        setIsLoading(true);
        setError(null);
        const userData = await getUserById(userId);
        setUser(userData);
      } catch (err) {
        setError('ユーザー情報の取得に失敗しました');
        console.error('Failed to fetch user:', err);
      } finally {
        setIsLoading(false);
      }
    }

    fetchUser();
  }, [userId]);

  if (isLoading) return <div>読み込み中...</div>;
  if (error) return <div className="text-red-500">{error}</div>;
  if (!user) return <div>ユーザーが見つかりません</div>;

  return <UserCard user={user} />;
}
```

## 📱 レスポンシブデザイン

### Tailwind CSS ブレークポイント
```tsx
// モバイルファースト
<div className="
  w-full           // モバイル: 100%
  md:w-1/2         // タブレット: 50%
  lg:w-1/3         // デスクトップ: 33%
  xl:w-1/4         // 大画面: 25%
">
  <Card>
    <CardContent>コンテンツ</CardContent>
  </Card>
</div>
```

## 🔍 SEO・アクセシビリティ

### メタデータ設定
```tsx
// app/[feature]/page.tsx
export const metadata: Metadata = {
  title: 'ページタイトル',
  description: 'ページの説明',
  keywords: ['キーワード1', 'キーワード2'],
};
```

### アクセシビリティ
```tsx
// セマンティックHTML
<main>
  <h1>メインタイトル</h1>
  <section aria-labelledby="section-title">
    <h2 id="section-title">セクションタイトル</h2>
    <button aria-label="詳細を開く">開く</button>
  </section>
</main>
```

## 🧪 テスト

### テスト方針
- **ユニットテスト**: 重要なビジネスロジック
- **コンポーネントテスト**: 複雑なUIコンポーネント
- **E2Eテスト**: 重要なユーザーフロー

### テスト例
```typescript
// __tests__/components/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '../Button';

describe('Button', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

## 📋 チェックリスト

開発時は以下の項目を確認してください：

- [ ] TypeScriptの型安全性が確保されているか
- [ ] Server Componentsを適切に使用しているか
- [ ] エラーハンドリングが実装されているか
- [ ] レスポンシブデザインが考慮されているか
- [ ] アクセシビリティが確保されているか
- [ ] パフォーマンスが最適化されているか
- [ ] 命名規則に従っているか
- [ ] ファイル構造が適切か
- [ ] テストが書かれているか（重要機能）
- [ ] SEO対策が施されているか

## 🚫 避けるべきパターン

- ❌ **any型の使用**
- ❌ **非同期処理の適切でない処理**
- ❌ **ハードコードされた値**
- ❌ **不適切なエラーハンドリング**
- ❌ **パフォーマンスを考慮しない実装**
- ❌ **アクセシビリティを無視した実装**
- ❌ **型安全性を無視した実装**




---
description: 
globs: 
alwaysApply: false
---
---
description: Guidelines for writing Next.js apps with tRPC
globs: "**/*.ts, **/*.tsx, **/*.js, **/*.jsx"
---

## 概要

[tRPC](mdc:https:/trpc.io)はエンドツーエンドの型安全なAPIを可能にし、スキーマ、コード生成、またはランタイムエラーなしでAPIを構築・消費できるようにします。これらのルールは、tRPC v11のベストプラクティスに従うのに役立ちます。

## プロジェクト構造

クリーンなtRPCセットアップのために、以下の推奨構造に従ってください:
```
.
├── src
│   ├── app
│   │   ├── _app.tsx  # ここに`createTRPCNext`セットアップを追加
│   │   ├── api
│   │   │   └── trpc
│   │   │       └── [trpc].ts  # tRPC HTTPハンドラー
│   │   ├── server
│   │   │   ├── routers
│   │   │   │   ├── _app.ts  # メインアプリルーター
│   │   │   │   ├── [feature].ts  # 機能固有のルーター
│   │   │   │   └── [...]
│   │   │   ├── context.ts   # アプリコンテキストを作成
│   │   │   └── trpc.ts      # プロシージャヘルパー
│   │   └── utils
│   │       └── trpc.ts  # 型安全なtRPCフック
```

## サーバーサイドセットアップ

### tRPCバックエンドの初期化

```typescript
// server/trpc.ts
import { initTRPC } from '@trpc/server';

// tRPCバックエンドを初期化（バックエンドごとに1回実行する必要があります）
const t = initTRPC.create();

// 再利用可能なルーターとプロシージャヘルパーをエクスポート
export const router = t.router;
export const publicProcedure = t.procedure;
```

### ルーターの作成

```typescript
// server/routers/_app.ts
import { z } from 'zod';
import { router, publicProcedure } from '../trpc';

export const appRouter = router({
  // ここにプロシージャを記述
  greeting: publicProcedure
    .input(z.object({ name: z.string() }))
    .query(({ input }) => {
      return `Hello ${input.name}`;
    }),
});

// APIの型定義をエクスポート（ルーター自体ではありません！）
export type AppRouter = typeof appRouter;
```

## クライアントサイドセットアップ

### Next.js統合

```typescript
// utils/trpc.ts
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import type { AppRouter } from '../server/routers/_app';

function getBaseUrl() {
  if (typeof window !== 'undefined') return ''; // ブラウザは相対パスを使用する必要があります
  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSRはvercel URLを使用する必要があります
  return `http://localhost:${process.env.PORT ?? 3000}`; // 開発SSRはlocalhostを使用する必要があります
}

export const trpc = createTRPCNext<AppRouter>({
  config() {
    return {
      links: [
        httpBatchLink({
          url: `${getBaseUrl()}/api/trpc`,
          // 必要に応じて認証ヘッダーを含める
          async headers() {
            return {
              // authorization: getAuthCookie(),
            };
          },
        }),
      ],
    };
  },
  ssr: false, // サーバーサイドレンダリングを使用したい場合はtrueに設定
});
```

## ベストプラクティス

1. **Zodを使用した入力検証**: より良い型安全性とランタイム検証のために、常にZodでプロシージャ入力を検証してください。

    ```typescript
    import { z } from 'zod';
    
    procedure
      .input(z.object({ 
        id: z.string().uuid(),
        email: z.string().email(),
        age: z.number().min(18) 
      }))
      .mutation(({ input }) => { /* あなたのコード */ })
    ```

2. **機能別にルーターを整理**: 1つの大きなルーターを持つよりも、論理的なドメイン/機能に基づいてルーターを分割してください。

    ```typescript
    // server/routers/user.ts
    export const userRouter = router({
      list: publicProcedure.query(() => { /* ... */ }),
      byId: publicProcedure.input(z.string()).query(({ input }) => { /* ... */ }),
      create: publicProcedure.input(/* ... */).mutation(({ input }) => { /* ... */ }),
    });
    
    // server/routers/_app.ts
    import { userRouter } from './user';
    import { postRouter } from './post';
    
    export const appRouter = router({
      user: userRouter,
      post: postRouter,
    });
    ```

3. **共通ロジックにミドルウェアを使用**: 認証、ログ記録、またはその他の横断的関心事にミドルウェアを適用してください。

    ```typescript
    const isAuthed = t.middleware(({ next, ctx }) => {
      if (!ctx.user) {
        throw new TRPCError({ code: 'UNAUTHORIZED' });
      }
      return next({
        ctx: {
          // コンテキストにユーザー情報を追加
          user: ctx.user,
        },
      });
    });
    
    const protectedProcedure = t.procedure.use(isAuthed);
    ```

4. **適切なエラーハンドリングを使用**: 一貫したエラーレスポンスのためにtRPCのエラーハンドリングを活用してください。

    ```typescript
    import { TRPCError } from '@trpc/server';
    
    publicProcedure
      .input(z.string())
      .query(({ input }) => {
        const user = getUserById(input);
        if (!user) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `ID ${input}のユーザーが見つかりません`,
          });
        }
        return user;
      });
    ```

5. **データトランスフォーマーを使用**: 日付、Maps、Setsなどの自動処理のためにSuperJSONを使用してください。

    ```typescript
    import { initTRPC } from '@trpc/server';
    import superjson from 'superjson';
    
    const t = initTRPC.create({
      transformer: superjson,
    });
    ```

6. **React Query統合を活用**: Reactプロジェクトでは、データフェッチ、ミューテーション、キャッシュのためにtRPCのReact Queryユーティリティを使用してください。

    ```tsx
    function UserProfile({ userId }: { userId: string }) {
      const { data, isLoading, error } = trpc.user.byId.useQuery(userId);
      
      if (isLoading) return <div>読み込み中...</div>;
      if (error) return <div>エラー: {error.message}</div>;
      
      return <div>{data.name}</div>;
    }
    ```

7. **コンテキスト作成**: プロシージャ間でリソースを共有するための適切なコンテキストオブジェクトを作成してください。

    ```typescript
    // server/context.ts
    import { inferAsyncReturnType } from '@trpc/server';
    import * as trpcNext from '@trpc/server/adapters/next';
    import { prisma } from './prisma';
    
    export async function createContext({
      req,
      res,
    }: trpcNext.CreateNextContextOptions) {
      const user = await getUser(req);
      return {
        req,
        res,
        prisma,
        user,
      };
    }
    
    export type Context = inferAsyncReturnType<typeof createContext>;
    ```

8. **型エクスポート**: サーバーコードからクライアントコードには、実際のルーター実装ではなく型のみをエクスポートしてください。

    ```typescript
    // ルーター自体ではなく、型ルーター型シグネチャをエクスポート
    export type AppRouter = typeof appRouter;
    ```

9. **プロシージャ型**: 異なる認証レベルに異なるプロシージャ型を使用してください。

    ```typescript
    export const publicProcedure = t.procedure;
    export const protectedProcedure = t.procedure.use(isAuthed);
    export const adminProcedure = t.procedure.use(isAdmin);
    ```

10. **パフォーマンス最適化**: 最適化されたデータ読み込みのためにバッチ処理とプリフェッチを使用してください。

    ```typescript
    // Next.jsセットアップでのクライアントサイドバッチ処理
    httpBatchLink({
      url: `${getBaseUrl()}/api/trpc`,
      maxURLLength: 2083,
    })
    
    // Next.jsでのデータプリフェッチ
    export async function getStaticProps() {
      const ssg = createServerSideHelpers({
        router: appRouter,
        ctx: {},
      });
      
      await ssg.post.byId.prefetch('1');
      
      return {
        props: {
          trpcState: ssg.dehydrate(),
        },
        revalidate: 1,
      };
    }
    ```

## バージョン互換性

このガイドはtRPC v11用で、以下が必要です：
- TypeScript >= 5.7.2
- 厳密なTypeScriptモード（tsconfig.jsonで`"strict": true`）

## その他のリソース

- [公式ドキュメント](mdc:https:/trpc.io/docs)
- [GitHubリポジトリ](mdc:https:/github.com/trpc/trpc)
- [サンプルアプリ](mdc:https:/trpc.io/docs/example-apps)



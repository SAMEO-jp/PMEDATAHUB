# 画面作成作業標準書

**文書バージョン**: 1.0
**作成日**: 2025-10-17
**対象システム**: PLM アプリケーション
**目的**: UI/UX開発の標準化

## 概要

この標準書は、PLMアプリケーションにおける画面作成の一貫した品質を保つための詳細な手順を定義します。

## 1. UI設計原則

### 1.1 デザインシステム
- **コンポーネントライブラリ**: shadcn/ui使用必須
- **スタイリング**: TailwindCSS使用
- **レスポンシブ**: モバイルファースト設計
- **アクセシビリティ**: WCAG 2.1 AA準拠

### 1.2 レイアウト構造
```
┌─────────────────────────────────────┐
│ Header (固定)                        │
├─────────────┬───────────────────────┤
│ Sidebar     │ Main Content          │
│ (左固定)    │ (可変)                │
│             │                       │
│ - メニュー   │ - ページヘッダー       │
│ - ナビ       │ - コンテンツエリア     │
│             │ - フッター             │
└─────────────┴───────────────────────┘
```

## 2. コンポーネント設計標準

### 2.1 ディレクトリ構造
```
src/apps/plm/components/
├── ui/                 # 基本UIコンポーネント
│   ├── button.tsx
│   ├── input.tsx
│   └── form.tsx
├── forms/              # フォーム専用コンポーネント
│   ├── employee-form.tsx
│   └── department-form.tsx
├── tables/             # テーブル専用コンポーネント
│   ├── employee-table.tsx
│   └── data-table.tsx
├── layouts/            # レイアウトコンポーネント
│   ├── sidebar.tsx
│   └── page-header.tsx
└── shared/             # 共通コンポーネント
    ├── loading.tsx
    └── error-boundary.tsx
```

### 2.2 コンポーネント命名規則
- **ファイル名**: kebab-case (例: `employee-form.tsx`)
- **コンポーネント名**: PascalCase (例: `EmployeeForm`)
- **Props型**: `[ComponentName]Props` (例: `EmployeeFormProps`)

### 2.3 基本コンポーネントテンプレート
```typescript
import { cn } from "@/lib/utils"

interface ComponentNameProps {
  className?: string
  children?: React.ReactNode
  // その他のprops
}

export function ComponentName({
  className,
  children,
  ...props
}: ComponentNameProps) {
  return (
    <div className={cn("base-styles", className)} {...props}>
      {children}
    </div>
  )
}
```

## 3. ページ作成標準

### 3.1 ページディレクトリ構造
```
src/apps/plm/pages/
├── employees/          # 社員管理
│   ├── page.tsx       # 一覧画面
│   ├── create/        # 新規登録
│   │   └── page.tsx
│   ├── [id]/          # 詳細・編集
│   │   ├── page.tsx   # 詳細画面
│   │   └── edit/      # 編集画面
│   │       └── page.tsx
└── departments/        # 部署管理
    └── ...（同様の構造）
```

### 3.2 ページコンポーネントテンプレート
```typescript
import { PageHeader } from "@/components/layouts/page-header"
import { Breadcrumb } from "@/components/ui/breadcrumb"

export default function PageName() {
  return (
    <div className="container mx-auto py-6">
      <Breadcrumb items={[
        { title: "ホーム", href: "/" },
        { title: "現在のページ", href: "#" }
      ]} />

      <PageHeader
        title="ページタイトル"
        description="ページの説明"
      />

      <main className="space-y-6">
        {/* メインコンテンツ */}
      </main>
    </div>
  )
}
```

## 4. フォーム作成標準

### 4.1 フォームライブラリ
- **バリデーション**: Zod使用
- **フォーム管理**: React Hook Form使用
- **統合**: @hookform/resolvers/zod

### 4.2 フォームスキーマ定義
```typescript
import { z } from "zod"

export const employeeSchema = z.object({
  employeeNumber: z.number().min(1, "社員番号は必須です"),
  lastName: z.string().min(1, "名字は必須です"),
  firstName: z.string().min(1, "名前は必須です"),
  departmentId: z.number().optional(),
  email: z.string().email("正しいメールアドレスを入力してください").optional(),
})

export type EmployeeFormData = z.infer<typeof employeeSchema>
```

### 4.3 フォームコンポーネントテンプレート
```typescript
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { Button } from "@/components/ui/button"
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"

interface EntityFormProps {
  defaultValues?: Partial<EntityFormData>
  onSubmit: (data: EntityFormData) => void
  isLoading?: boolean
}

export function EntityForm({
  defaultValues,
  onSubmit,
  isLoading
}: EntityFormProps) {
  const form = useForm<EntityFormData>({
    resolver: zodResolver(entitySchema),
    defaultValues,
  })

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="fieldName"
          render={({ field }) => (
            <FormItem>
              <FormLabel>フィールド名</FormLabel>
              <FormControl>
                <Input placeholder="入力してください" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" disabled={isLoading}>
          {isLoading ? "保存中..." : "保存"}
        </Button>
      </form>
    </Form>
  )
}
```

## 5. テーブル作成標準

### 5.1 データテーブル基本構造
```typescript
import { DataTable } from "@/components/ui/data-table"
import { ColumnDef } from "@tanstack/react-table"

const columns: ColumnDef<EntityType>[] = [
  {
    accessorKey: "id",
    header: "ID",
  },
  {
    accessorKey: "name",
    header: "名前",
  },
  {
    id: "actions",
    header: "操作",
    cell: ({ row }) => (
      <div className="flex gap-2">
        <Button variant="outline" size="sm">編集</Button>
        <Button variant="destructive" size="sm">削除</Button>
      </div>
    ),
  },
]

export function EntityTable({ data }: { data: EntityType[] }) {
  return (
    <DataTable
      columns={columns}
      data={data}
      searchKey="name"
      searchPlaceholder="名前で検索..."
    />
  )
}
```

## 6. 状態管理標準

### 6.1 クライアント状態
- **フォーム状態**: React Hook Form
- **UI状態**: useState, useReducer
- **グローバル状態**: Zustand (必要に応じて)

### 6.2 サーバー状態
- **データフェッチング**: tRPC hooks
- **キャッシュ**: TanStack Query (tRPC統合)
- **楽観的更新**: tRPC mutations

### 6.3 状態管理例
```typescript
import { api } from "@/lib/api"

export function EmployeeList() {
  const { data: employees, isLoading, error } = api.employee.list.useQuery()
  const createMutation = api.employee.create.useMutation({
    onSuccess: () => {
      // キャッシュの無効化
      utils.employee.list.invalidate()
    }
  })

  if (isLoading) return <Loading />
  if (error) return <ErrorMessage error={error} />

  return (
    <div>
      <EmployeeTable data={employees || []} />
    </div>
  )
}
```

## 7. エラーハンドリング標準

### 7.1 エラー境界
```typescript
import { ErrorBoundary } from "react-error-boundary"

function ErrorFallback({ error }: { error: Error }) {
  return (
    <div className="text-center py-8">
      <h2 className="text-lg font-semibold text-red-600">
        エラーが発生しました
      </h2>
      <p className="text-sm text-gray-600 mt-2">
        {error.message}
      </p>
      <Button
        onClick={() => window.location.reload()}
        className="mt-4"
      >
        ページを再読み込み
      </Button>
    </div>
  )
}

export function PageWithErrorBoundary() {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <PageContent />
    </ErrorBoundary>
  )
}
```

### 7.2 フォームエラー
```typescript
// バリデーションエラーの表示
<FormMessage /> // react-hook-formと統合

// APIエラーの表示
{mutation.error && (
  <Alert variant="destructive">
    <AlertDescription>
      {mutation.error.message}
    </AlertDescription>
  </Alert>
)}
```

## 8. パフォーマンス最適化

### 8.1 コンポーネント最適化
```typescript
import { memo, useMemo, useCallback } from "react"

export const OptimizedComponent = memo(function OptimizedComponent({
  data,
  onUpdate
}: Props) {
  const processedData = useMemo(() => {
    return data.map(item => ({ ...item, processed: true }))
  }, [data])

  const handleUpdate = useCallback((id: string) => {
    onUpdate(id)
  }, [onUpdate])

  return (
    <div>
      {/* レンダリング内容 */}
    </div>
  )
})
```

### 8.2 画像最適化
```typescript
import Image from "next/image"

<Image
  src="/images/photo.jpg"
  alt="説明文"
  width={300}
  height={200}
  className="rounded-lg"
  priority // 重要な画像の場合
/>
```

## 9. テスト標準

### 9.1 コンポーネントテスト
```typescript
import { render, screen, fireEvent } from "@testing-library/react"
import { EmployeeForm } from "./employee-form"

describe("EmployeeForm", () => {
  it("should submit form with valid data", async () => {
    const onSubmit = jest.fn()

    render(<EmployeeForm onSubmit={onSubmit} />)

    fireEvent.change(screen.getByLabelText("名前"), {
      target: { value: "田中太郎" }
    })

    fireEvent.click(screen.getByRole("button", { name: "保存" }))

    await waitFor(() => {
      expect(onSubmit).toHaveBeenCalledWith({
        name: "田中太郎"
      })
    })
  })
})
```

## 10. 品質チェックリスト

### 10.1 実装品質
- [ ] TypeScript型安全性の確保
- [ ] ESLintルールの遵守
- [ ] アクセシビリティの確認
- [ ] レスポンシブデザインの確認

### 10.2 UX品質
- [ ] ローディング状態の表示
- [ ] エラー状態の適切な処理
- [ ] フォームバリデーションの実装
- [ ] 操作フィードバックの提供

### 10.3 パフォーマンス
- [ ] 不要な再レンダリングの回避
- [ ] 画像最適化の実装
- [ ] バンドルサイズの確認
- [ ] Core Web Vitalsの測定

---

この標準書に従うことで、一貫した品質のUI開発が可能になります。